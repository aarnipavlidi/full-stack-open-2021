{"version":3,"sources":["components/Persons.js","services/notesPersons.js","App.js","index.js"],"names":["PersonsComponent","props","personValue","filter","a","name","toLowerCase","includes","filterNameValue","map","b","number","value","id","onClick","deleteValue","database","axios","get","then","response","data","newValue","post","changeValue","put","delete","InputComponent","valueProps","onChange","onChangeProps","placeholder","placeholderProps","FormComponent","onSubmit","onSubmitProps","nameValue","nameChange","namePlace","numberValue","numberChange","numberPlace","type","typeProps","Notification","message","checkStatus","className","App","useState","persons","setPersons","status","setStatus","statusMessage","setStatusMessage","useEffect","notesService","showResults","console","log","filterName","setFilterName","newName","setNewName","newNumber","setNewNumber","event","target","preventDefault","nameObject","date","Date","toISOString","important","Math","random","length","findCurrentName","find","findValue","changeCurrentName","some","personsSearch","window","confirm","results","index","setTimeout","catch","error","concat","Persons","buttonID","getPerson","filterValue","updatedList","newlist","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.c68cee93.chunk.js","sourcesContent":["// This exercise has been commented by Aarni Pavlidi, if you have any questions or suggestions with the code,\r\n// then please contact me by sending email at me@aarnipavlidi.fi <3\r\n\r\nimport React from 'react' // Otetaan \"React\" kirjaston sisältö käyttöön.\r\n\r\n// Luodaan komponentti nimeltään \"PersonsComponent\", joka palauttaa alla olevan arvon return() sisältä takaisin App komponenttiin.\r\n//\r\n// props.personValue.filter(...) on sama asia kuin => persons.filter(...) ja \"persons\" muuttuja on alustettu App komponentissa.\r\n// .includes(props.filterNameValue) on sama asia kuin => .includes(filterName) ja \"filterName\" muuttuja on alustettu App komponentissa.\r\n//\r\n// Meidän ei tarvitse käyttää muita propseja tässä komponentissa, koska kaikki muut muuttujat tulee \"customina\" eli vaikka niitä muuttaisi, niin koodi siitä huolimatta toimisi.\r\n// <li key={b.name}> tarkoittaa, että jokaiselle riville mikä renderöitään (tai kun käyttäjä lisää uuden tiedon puhelinluetteloon) niin sille annetaan uniikki arvo (name).\r\n\r\nconst PersonsComponent = (props) => {\r\n  return(\r\n    <ul>\r\n      {props.personValue.filter(a => a.name.toLowerCase().includes(props.filterNameValue.toLowerCase())).map(b =>\r\n        <li key={b.name}>Name: {b.name}, {b.number} (phone number) <button value={b.id} onClick={props.deleteValue}>delete</button></li> // {b.name} + {b.phonenumber} + {b.id} = hakee arvot muuttujasta \"persons\" ja näyttää \"name\", \"phonenumber\" sekä \"id\" arvot käyttäjälle.\r\n      )}\r\n    </ul>\r\n  )\r\n}\r\n\r\nexport default PersonsComponent\r\n","// This exercise has been commented by Aarni Pavlidi, if you have any questions or suggestions with the code,\r\n// then please contact me by sending email at me@aarnipavlidi.fi <3\r\n\r\nimport axios from 'axios' // Otetaan \"Axios\" kirjaston sisältö käyttöön.\r\nconst database = '/api/persons' // Alustetaan muuttuja \"database\", joka hyödyntää \"db.json\" arvoja, joka sijaitsee kyseisellä sivulla.\r\n\r\n// Alustetaan muuttuja \"getAllValues\", jonka tarkoituksena ottaa arvot \"database\" muuttujan sisältä ja palauttaa (return request.then) takaisin käyttäjälle näkyviin.\r\n// Kun käyttäjä avaa sivun ensimmäisen kerran, niin sivulle renderöitään tiedot tietokannasta tämän muuttujan kautta.\r\nconst getAllValues = () => {\r\n  const request = axios.get(database) // Muuttuja \"database\" alustettu rivillä 2.\r\n  return request.then(response => {\r\n    return response.data // Kun funktio on suoriettu, niin sen hetkinen data tallennetaan \"response.data\" alle, jotta sen muuttujan dataa voidaan hyödyntää sivulla. Jos tätä ei olisi, niin tulisi erroria!\r\n  })\r\n}\r\n\r\n// Alustetaan muuttuja \"createValue\", jonka tarkoituksena on toimia niin kun käyttäjä haluaa haluaa lisätä uudet tiedot tietokantaan, niin me otetaan käyttäjän antamat tiedot \"newValue\" muuttujan alle ja sijoitetaan ne tietokantaan \"database\" muuttujan avulla.\r\n// Aina kun käyttäjä haluaa lisätä uudet tiedot tietokantaan, niin sivu suorittaa aina kyseisen funktion eli => \"createValue(...)\".\r\nconst createValue = (newValue) => { // Alustetaan myös \"newValue\" muuttujan käyttö funktion sisällä. Jos tätä ei olisi, niin tulisi erroria!\r\n  const request = axios.post(database, newValue) // Muuttuja \"database\" alustettu rivillä 2.\r\n  return request.then(response => {\r\n    return response.data // Kun funktio on suoritettu, niin sen hetkinen data tallennetaan \"response.data\" alle, jotta sen muuttujan dataa voidaan hyödyntää sivulla. Jos tätä ei olisi, niin tulisi erroria!\r\n  })\r\n}\r\n\r\n// Alustetaan muuttuja \"updateValue\", jonka tarkoituksena on toimia niin kun käyttäjä haluaa päivittää nykyistä tietoa tietokannan sisällä, niin me siirrytään tietokannassa tiettyyn taulukon arvoon esim. => http://localhost:3001/persons/1 ja päivitetään sen sisällä haluttua arvoa.\r\n// Aina kun käyttäjä haluaa päivittää tietokannan nykyisiä tietoja, niin sivu suorittaa aina kyseisen funktion eli => \"updateValue(...)\".\r\nconst updateValue = (id, changeValue) => { // Alustetaan myös \"id\" + \"changeValue\" muuttujien käyttö funktion sisällä. Jos tätä ei olisi, niin tulisi erroria!\r\n  const request = axios.put(`${database}/${id}`, changeValue) // Muuttuja \"database\" alustettu rivillä 2.\r\n  return request.then(response => {\r\n    return response.data // Kun funktio on suoritettu, niin sen hetkinen data tallennetaan \"response.data\" alle, jotta sen muuttujan dataa voidaan hyödyntää sivulla. Jos tätä ei olisi, niin tulisi erroria!\r\n  })\r\n}\r\n\r\n// Alustetaan muuttuja \"deleteValue\", jonka tarkoituksena on toimia niin kun käyttäjä haluaa poistaa tietoja tietokannan sisältä, niin ne poistuu id:n perusteella lopullisesti.\r\n// Muista myös, että painikkeen \"value\" arvo määrittää {id}:n eli, jos painikkeen \"value\" on 2 niin tämä kyseinen muuttuja poistaa tiedot tietokannasta => \"http://localhost:3001/persons/2\" lopullisesti.\r\n// Aina kun käyttäjä haluaa poistaa tietokannan tietoja, niin sivu suorittaa aina kyseisen funktion eli => \"deleteValue(...)\".\r\nconst deleteValue = (id) => { // Alustetaan myös \"id\" muuttujan käyttö funktion sisällä. Jos tätä ei olisi, niin tulisi erroria!\r\n  const request = axios.delete(`${database}/${id}`) // Muuttuja \"database\" alustettu rivillä 2.\r\n  return request.then(response => {\r\n    return response.data // Kun funktio on suoritettu, niin sen hetkinen data tallennetaan \"response.data\" alle, jotta sen muuttujan dataa voidaan hyödyntää sivulla. Jos tätä ei olisi, niin tulisi erroria!\r\n  })\r\n}\r\n\r\n// Kyseisten muuttujien \"export\", jos tätä ei olisi, niin näitä ei pystyisi käyttämään \"App.js\" sisällä.\r\nexport default { getAllValues, createValue, updateValue, deleteValue } // Ota huomioon, että tämä pitää myös importtaa \"App.js\" sisällä esim. seuraavalla tavalla ==> import notesService from './services/notesPersons'.\r\n","// This exercise has been commented by Aarni Pavlidi, if you have any questions or suggestions with the code,\n// then please contact me by sending email at me@aarnipavlidi.fi <3\n\nimport React, { useState, useEffect } from 'react' // Otetaan \"React\" kirjaston sisältö käyttöön, joka myös hyödyntää \"useState\" ja \"useEffect\" funktioita.\nimport axios from 'axios' // Otetaan \"Axios\" kirjaston sisältö käyttöön.\nimport PersonsComponent from './components/Persons' // Tuodaan \"PersonsComponent\" komponentti käyttöön, joka sijaitsee kyseisellä sivulla.\nimport notesService from './services/notesPersons' // Alustetaan muuttuja \"notesService\", joka hyödyntää \"notesPersons.js\" moduulin sisältöä.\n\nconst InputComponent = (props) => {\n  return (\n    <div>\n      <input\n        value={props.valueProps}\n        onChange={props.onChangeProps}\n        placeholder={props.placeholderProps}\n      />\n    </div>\n  )\n}\n\nconst FormComponent = (props) => {\n  return (\n    <form onSubmit={props.onSubmitProps}>\n      <div>\n        <input\n          value={props.nameValue}\n          onChange={props.nameChange}\n          placeholder={props.namePlace}\n          />\n      </div>\n      <div>\n        <input\n          value={props.numberValue}\n          onChange={props.numberChange}\n          placeholder={props.numberPlace}\n        />\n      </div>\n      <button type={props.typeProps}>Add</button>\n    </form>\n  )\n}\n\n// Luodaan komponentti \"Notification\", jonka sisälle luodaan kaksi (2) erilaista muuttujaa => \"message\" ja \"checkStatus\" käytettäväksi komponentin sisällä.\n// Riviltä 212 löytyy => \"<Notification message={statusMessage} checkStatus={status} />\" ja kuten huomataan, niin nämä kaksi (2) muuttujaa on viitattu olemaan yhtä kuin x muuttujan kanssa.\n// Jos näitä kahta (2) muuttujaa ei olisi laitettu esim. => \"const Notification = () => {...}\" niin alla oleva komponentti ei toimisi ollenkaan!\nconst Notification = ({ message, checkStatus }) => {\n  if (message === null) { // Jos muuttuja \"message\" => {statusMessage} on arvoa \"null\" niin mitään ei renderöidä takaisin käyttäjälle.\n    return null\n  }\n\n  if (message != null && checkStatus === false) { // Jos muuttuja \"message\" => {statusMessage} on epätosi arvon \"null\" kanssa ja muuttuja \"checkStatus\" => {status} on yhtä kuin \"false\", niin renderöidään alla oleva asia.\n    return ( // Alla oleva <div>...</div> elementti hyödyntää .error tyyliä, jonka se poimii => index.css tiedostosta.\n      <div className=\"error\">\n        {message}\n      </div>\n    )\n  }\n\n  else if (message != null && checkStatus === true) { // Jos muuttuja \"message\" => {statusMessage} on epätosi arvon \"null\" kanssa ja muuttuja \"checkStatus\" => {status} on yhtä kuin \"true\", niin renderöidään alla oleva asia.\n    return ( // Alla oleva <div>...</div> elementti hyödyntää .success tyyliä, jonka se poimii => index.css tiedostosta.\n      <div className=\"success\">\n        {message}\n      </div>\n    )\n  }\n}\n\nconst App = () => {\n  const [persons, setPersons] = useState([]) // Alustetaan muuttuja \"persons\" tilaan, joka saa oletuksena arvon => [] eli tyhjän taulukon ja jos haluamme muuttaa tilan arvoa, niin käytämme funktiota => \"setPersons\".\n\n  const [status, setStatus] = useState(true) // Alustetaan muuttuja \"status\" tilaan, joka saa oletuksena arvon \"true\" ja jos haluamme muuttaa tilan arvoa, niin käytämme funktiota => \"setStatus\".\n  const [statusMessage, setStatusMessage] = useState(null) // Alustetaan muuttuja \"statusMessage\" tilaan, joka saa oletuksena arvon \"null\" ja jos haluamme muuttaa tilan arvoa, niin käytämme funktiota => \"setStatusMessage\".\n\n  useEffect(() =>  {\n    notesService // Käytetään muuttujan \"notesService\" moduulin sisältöä, josta löytyy muuttuja => \"const getAllValues = () =>\".\n      .getAllValues() // Mikä tarkoittaa, että ensin tehdään kyseisen muuttujan funktiot, joka palauttaa takaisin datan (esim. => fetchValues.data) käytettäväksi.\n      .then(showResults => { // Muuttuja \"showResults\" voi olla myös esim. \"Aarni\" eli .then(Aarni => ...).\n        setPersons(showResults) // Tämän jälkeen muutetaan \"persons\" taulukon tilaa käyttämällä \"setPersons\" funktiota, joka hyödyntää muuttujan \"showResults\" arvoja. Ota huomioon, että kyseinen muuttuja voi olla mikä tahansa!\n        console.log(showResults) // Tulostetaan konsoliin \"showResults\" muuttujan arvot.\n        })\n  }, []) // Käytämme funktion \"useEffect\" lopussa [], koska haluamme että kyseinen funktio renderöi sivulle vain kerran.\n\n  const [filterName, setFilterName] = useState('') // Alustetaan muuttuja \"filterName\" tilaan, joka saa oletuksena arvon => '' ja jos haluamme muuttaa tilan arvoa, niin käytämme funktiota => \"setFilterName\".\n  const [newName, setNewName] = useState('') // Alustetaan muuttuja \"newName\" tilaan, joka saa oletuksena arvon => '' ja jos haluamme muuttaa tilan arvoa, niin käytämme funktiota => \"setNewName\".\n  const [newNumber, setNewNumber] = useState('') // Alustetaan muuttuja \"newNumber\" tilaan, joka saa oletuksena arvon => '' ja joa haluamme muuttaa tilan arvoa, niin käytämme funktiota => \"setNewNumber\".\n\n  const inputTextFilter = \"What do you want to filter?\" // Alustetaan muuttuja, joka sijoittuu filtteröinnin input:iin (InputComponent => props).\n  const inputTextName = \"Add new persons name...\" // Alustetaan muuuttuja, joka sijoittuu nimen lisäämisen input:iin (FormComponent => props).\n  const inputTextNumber = \"Add new persons phone number...\" // Alustetaan muuttuja, joka sijoittuu numeron lisäämisen input:iin (FormComponent => props).\n\n  // Kun käyttäjä lisää uudet tiedot luetteloon, niin se tekee alla olevan funktion (submitPerson) ja tallentaa tiedot \"väliaikaisesti\" \"nameObject\" muuttujan alle.\n  // Muuttujan \"nameObject\" taulukko voi olla seuraavanlainen esim. nameObject[0] => {name, phonenumber, date, important, id} => {\"Aarni Pavlidi\", 050 123 456, \"2021-02-10T19:31:07.280Z\", true, 3}.\n  const submitPerson = (event) => {\n    event.preventDefault()\n    const nameObject = {\n      name: newName,\n      number: newNumber,\n      date: new Date().toISOString(),\n      important: Math.random() > 0.5,\n      id: persons.length + 1,\n    }\n\n    // Kun käyttäjä haluaa lisätä henkilön nimen niin se tallennetaan \"väliaikaisesti\" muuttujan \"nameObject.name\" alle ja muista, että kyseinen muuttuja on sama arvo kuin muuttuja \"newName\".\n    // Kun käyttäjä haluaa lisätä henkilön nimen lisäksi puhelinnumeron, niin se tallennetaan \"väliaikaisesti\" muuttujan \"nameObject.number\" alla ja muista, että kyseinen muuttuja on sama arvo kuin muuttuja \"newNumber\".\n    const findCurrentName = persons.find(findValue => findValue.name === nameObject.name) // Alustetaan muuttuja \"findCurrentName\", jossa etsitään taulukko (array), jonka \"name\" objekti täsmää käyttäjän antamalla arvolla eli \"nameObject.name\" tai \"newName\".\n    const changeCurrentName = { ...findCurrentName, number: nameObject.number } // Alustetaan muuttuja \"changeCurrentName\", jossa tehdään muuttujan \"findCurrentName\" taulukosta kopio (Shallow copy) ja muutetaan kyseisen objektin \"number\" arvo käyttämällä käyttäjän antamaa arvoa eli \"nameObject.number\" tai \"newNumber\".\n\n    // Mikäli käyttäjä yrittää lisätä nimen, joka löytyy jo taulukosta entuudestaan niin se tulostaa näyttöön hälytyksen (=> window.confirm(...)) ja ilmoittaa, että haluaako käyttäjä päivittää kyseisen nimen puhelinnumeron.\n    // Mikäli käyttäjä lisää nimen, jota ei löydy taulukosta entuudestaan, niin se tulostaa uudet tiedot näkyviin käyttäjälle (else => setPersons(...)).\n    if(persons.some(personsSearch => personsSearch.name === newName)) {\n      if(window.confirm(`${nameObject.name} is already added to the records. Do you want to update the old number with a new one?`)) {\n        notesService // Käytetään muuttujan \"notesService\" moduulin sisältöä, josta löytyy muuttuja => \"const updateValue = (id, changeValue) =>\".\n          .updateValue(findCurrentName.id, changeCurrentName) // Jos findCurrentName.id  olisi esim. => \"1\" niin .updateValue() funktio siirtyy osoitteeseen => http://localhost:3001/persons/1 ja päivittää siellä kyseistä objektia eli tässä tapauksessa \"number\" arvoa.\n          .then(response => { // Kun \"updateValue()\" funktio on suoritettu, niin se tallentaa kyseisen id:n sisällön väliaikaisesti muuttujan \"response\" alle eli jos käyttäisimme \"console.log(response)\" funktiota => .then(...) sisällä, niin saisimme päivitetyn taulukon arvon tulostettua konsolille.\n            // Muutetaan \"persons\" muuttujan tilaa käyttämällä \"map()\" funktiota, joka luo meille uuden taulukon (creates a new array). Huomaat myös, että käytämmmä tässä \"index\" muuttujaa \"map()\" funktion sisällä eli jos taulukossa on 4 erilaista arvoa, niin \"index\" muuttuja voi olla seuraavat arvot => [0, 1, 2, 3].\n            setPersons(persons.map((results, index) => results.id !== findCurrentName.id ? persons[index] : response)) // Jos taulukon sisällä oleva arvo => \"results.id\" ei täsmää (tai on epätosi) => muuttujan \"findCurrentName.id\":n kanssa, niin käytetään alkuperäisiä arvoja => \"persons[index]\" ja jos täsmää, niin käytetään muuttujan \"response\" arvoja ja vaihdetaan ne nykyisten arvojen kanssa.\n            setFilterName('') // Mikäli käyttäjä hyväksyy \"windown.confirm()\" hälytyksen, niin se muuttaa \"filterName\" muuttujan alkuperäiseen tilaan eli tyhjentää sen hetkisen muuttujan arvon.\n            setNewName('') // Mikäli käyttäjä hyväksyy \"window.confirm()\" hälytyksen, niin se muuttaa \"newName\" muuttujan alkuperäiseen tilaan eli tyhjentää sen hetkisen muuttujan arvon.\n            setNewNumber('') // Mikäli käyttäjä hyväksyy \"window.confirm()\" hälytyksen, niin se muuttaa \"newNumber\" muuttujan alkuperäiseen tilaan eli tyhjentää sen hetkisen muuttujan arvon.\n            setStatus(true) // Muutetaan \"status\" muuttujan arvoksi => \"true\". Tätä ei periaatteessa ei tarvitse olla tässä, koska jos henkilön päivittäminen epäonnistuu, niin siinä muutetaan sama muuttuja arvoon => \"false\" ja sen jälkeen takaisin arvoon \"true\", mutta tällä varmistetaan aina se, että henkilön päivittäminen renderöi oikean ilmoituksen takaisin käyttäjälle näkyviin.\n            setStatusMessage(` You have updated ${nameObject.name} successfully on the phonebook! `) // Muutetaan \"statusMessage\" muuttujan arvo kyseiseen tekstiin. Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n            setTimeout(() => { // Käytetään \"setTimeOut()\" funktiota, jotta saadaan ilmoitus poistumaan tietyn ajan päästä eli tässä tapauksessa ilmoitus poistuu näytöltä 2. sekunnin (eli 2000 ms) kuluttua.\n              setStatusMessage(null) // Muutetaan \"statusMessage\" muuttujan arvoksi => \"null\". Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n            }, 2000)\n          })\n          .catch(error => { // Mikäli tulee virheitä, kun yritetään päivittää puhelinluettelon henkilöä, niin ohjelma suorittaa {...} sisällä olevat asiat ja renderöi ne takaisin käyttäjälle näkyviin.\n            setStatus(false) // Muutetaan \"status\" muuttujan arvoksi => \"false\". Muista, että kyseinen muuttuja on yhtä kuin {checkStatus} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n            setStatusMessage(` Updating ${nameObject.name} on the phonebook was unsuccessful. Please try again! :) `) // Muutetaan \"statusMessage\" muuttujan arvo kyseiseen tekstiin. Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n            setTimeout(() => { // Käytetään \"setTimeOut()\" funktiota, jotta saadaan ilmoitus poistumaan tietyn ajan päästä eli tässä tapauksessa ilmoitus poistuu näytöltä 3. sekunnin (eli 3000 ms) kuluttua.\n              setStatus(true) // Muutetaan \"status\" muuttuja oletusarvoon eli \"true\". Muista, että kyseinen muuttuja on yhtä kuin {checkStatus} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n              setStatusMessage(null) // Muutetaan \"statusMessage\" muuttujan arvoksi => \"null\". Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n            }, 3000)\n          })\n        }\n      } else { // Mikäli käyttäjän lisämää nimeä ei löydy luettelosta, niin lisätään arvot kyseisellä muuttujan arvolla (nameObject) kyseiseen sivuun, joka on .json muodossa.\n        notesService // Käytetään muuttujan \"notesService\" moduulin sisältöä, josta löytyy muuttuja => \"const createValue = (newValue) =>\".\n        .createValue(nameObject) // Päivitetään luetteloa käyttämällä muuttujan \"nameObject\" arvoa. Muuttujan sisältä löytyy arvot => name, number, date, important ja id.\n        .then(newValue => { // Kun \"createValue()\" funktio on suoritettu, niin se tallentaa käyttäjän antamat arvot väliaikaisesti muuttujan \"newValue\" alle eli jos käyttäisimme \"console.log(newValue)\" funktiota => .then(...) sisällä, niin saisimme käyttäjän antamat arvot tulostettua konsoliin.\n          setPersons(persons.concat(newValue)) // Muutetaan muuttujan \"persons\" tilaa käyttämällä \"setPersons\" funkiota ja funktion \"concat\" avulla me emme muutta komponentin alkuperäistä tilaa, vaan luodaan uusi taulukko!\n          setFilterName('') // Kun sivu suorittaa tämän funktion (submitPerson), niin se tyhjentää kyseisen muuttujan taulukon. Mikäli tätä ei olisi, niin se arvo minkä käyttäjä antaa input:iin jäisi ns. \"roikkumaan\" näkyviin.\n          setNewName('') // Kun sivu suorittaa tämän funktion (submitPerson), niin se tyhjentää kyseisen muuttujan taulukon. Mikäli tätä ei olisi, niin se arvo minkä käyttäjä antaa input:iin jäisi ns. \"roikkumaan\" näkyviin.\n          setNewNumber('') // Kun sivu suorittaa tämän funktion (submitPerson), niin se tyhjentää kyseisen muuttujan taulukon. Mikäli tätä ei olisi, niin se arvo minkä käyttäjä antaa input:iin jäisi ns. \"roikkumaan\" näkyviin.\n          setStatus(true) // Muutetaan \"status\" muuttujan arvoksi => \"true\". Tätä ei periaatteessa ei tarvitse olla tässä, koska jos henkilön lisääminen epäonnistuu, niin siinä muutetaan sama muuttuja arvoon => \"false\" ja sen jälkeen takaisin arvoon \"true\", mutta tällä varmistetaan aina se, että henkilön lisääminen renderöi oikean ilmoituksen takaisin käyttäjälle näkyviin.\n          setStatusMessage(` You have added ${nameObject.name} successfully to the phonebook! `) // Muutetaan \"statusMessage\" muuttujan arvo kyseiseen tekstiin. Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          setTimeout(() => { // Käytetään \"setTimeOut()\" funktiota, jotta saadaan ilmoitus poistumaan tietyn ajan päästä eli tässä tapauksessa ilmoitus poistuu näytöltä 2. sekunnin (eli 2000 ms) kuluttua.\n            setStatusMessage(null) // Muutetaan \"statusMessage\" muuttujan arvoksi => \"null\". Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          }, 2000)\n        })\n        .catch(error => { // Mikäli tulee virheitä, kun yritetään lisätä puhelinluetteloon uutta henkilöä, niin ohjelma suorittaa {...} sisällä olevat asiat ja renderöi ne takaisin käyttäjälle näkyviin.\n          setStatus(false) // Muutetaan \"status\" muuttujan arvoksi => \"false\". Muista, että kyseinen muuttuja on yhtä kuin {checkStatus} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          setStatusMessage(` Adding ${nameObject.name} to the phonebook was unsuccessful. Please try again! :) `) // Muutetaan \"statusMessage\" muuttujan arvo kyseiseen tekstiin. Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          setTimeout(() => { // Käytetään \"setTimeOut()\" funktiota, jotta saadaan ilmoitus poistumaan tietyn ajan päästä eli tässä tapauksessa ilmoitus poistuu näytöltä 3. sekunnin (eli 3000 ms) kuluttua.\n            setStatus(true) // Muutetaan \"status\" muuttuja oletusarvoon eli \"true\". Muista, että kyseinen muuttuja on yhtä kuin {checkStatus} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n            setStatusMessage(null) // Muutetaan \"statusMessage\" muuttujan arvoksi => \"null\". Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          }, 3000)\n        })\n      }\n    }\n\n  // Input:sta (missä filtteröidään nimi) löytyy \"value={filterName}\", niin käytännössä tämä muuttuja tallentaa (=> setFilterName) kaiken mitä käyttäjä kirjoittaa.\n  const handleFilterNameChange = (event) => {\n    console.log(event.target.value) // = console.log(filterName) tulostaa saman asian ja ennen kuin käyttäjä kirjoittaa mitään input:iin, niin => filterName = ''.\n    setFilterName(event.target.value) // Kun käyttäjä kirjoittaa arvon esim. \"Aarni\" niin funktio => setFilterName tallentaa sen arvon, joten filterName = Aarni.\n  }\n\n  // Input:sta (missä lisätään uusi nimi) löytyy \"value={newName}\", niin käytännössä tämä muuttuja tallentaa (=> setNewName) kaiken mitä käyttäjä kirjoittaa.\n  const handleNameChange = (event) => {\n    console.log(event.target.value) // = console.log(newName) tulostaa saman asian ja ennen kuin käyttäjä kirjoittaa mitään input:iin, niin => newName = ''.\n    setNewName(event.target.value) // Kun käyttäjä kirjoittaa arvon esim. \"Aarni Pavlidi\" niin funktio => setNewName tallentaa sen arvon, joten newName = Aarni Pavlidi.\n  }\n\n  // Input:sta (missä lisätään uusi numero) löytyy \"value={newNumber}\", niin käytännössä tämä muuttuja tallentaa (=> setNewNumber) kaiken mitä käyttäjä kirjoittaa.\n  const handleNumberChange = (event) => {\n    console.log(event.target.value) // console.log(newNumber) tulostaa saman asian ja ennen kuin käyttäjä kirjoittaa mitään input:iin, niin => newNumber = ''.\n    setNewNumber(event.target.value) // Kun käyttäjä kirjoittaa arvon esim. \"123 456\" niin funktio => setNewNumber tallentaa sen arvon, joten newNumber = 123 456.\n  }\n\n  // Alustetaan muuttuja \"handePersonDelete\" ja miten tämän muuttujan funktiota käytetään, niin jokaiselle puhelinluettelossa olevalla nimelle ilmestyy painike \"delete\" tietojen perään.\n  // Tämä painike saa arvoksi sen rivin olevan taulukon id:n arvon eli jos \"persons\" muuttujan ensimmäinen id on \"1\" niin sen kyseisen rivin painike saa myös saman arvon.\n  // Tämän painikkeen toiminnallisuus on toteutettu komponentin => \"PersonsComponent\" alla. Katso rivi 3. => import PersonsComponent from './components/Persons'.\n  // Painike voi olla esim. seuraavanlainen => <button value=\"1\">delete</button> (näin se voisi näkyä, jos tarkasteltaisiin painiketta sivun kautta!).\n  const handlePersonDelete = (event) => {\n    // Ota huomioon, että nämä 2x alla olevaa riviä oli ennen seuraavalla tavalla:\n    // const buttonID = parseInt(event.target.value) || Katso kommentti ==> Task02 - puhelinluettelo - step9 - App_step9.js\n    // const getIndex = buttonID - 1 || Katso kommentti ==> Task02 - puhelinluettelo - step9 - App_step9.js\n\n    // Ja nyt ollaan muokattu tehtävää \"puhelinluettelo ja tietokanta, step3\" tehtävää varten!\n    const buttonID = event.target.value // Alustetaan muuttuja \"buttonID\" ja me käytämme tässä \"parseInt()\" funktiota, koska haluamme päästä eroon => \"...\" eli funktion jälkeen \"1\" on 1.\n    const getPerson = persons.find(filterValue => filterValue.id === buttonID) // Alustetaan muuttuja \"getPerson\", joka käyttää \"find(...)\" funktiota. Jokaisella painikkella on oma uniikki \"id\" ja sen avulla filtteröidään \"persons\" taulukosta kaikki ne arvot, mitkä eivät vastaa painetun painikkeen \"id\":n arvon kanssa!\n\n    // Kun käyttäjä haluaa poistaa x tiedot luettelosta, niin näyttöön tulee hälytys (window.confirm), että haluaako käyttäjä varmasti poistaa kyseiset tiedot tietokannasta. Mikäli käyttäjä vahvistaa, niin se tekee alla olevat funktiot ja jos käyttäjä peruu, niin se ei tee mitään ja palaa takaisin.\n    if (window.confirm(`Are you sure you want to delete ${getPerson.name} from the records?`)) {\n      notesService // Käytetään muuttujan \"notesService\" moduulin sisältöä, josta löytyy muuttuja => \"const deleteValue = (id) =>\".\n        .deleteValue(event.target.value) // Suoritetaan deleteValue(...) funktio, joka poistaa kyseisen rivin tiedot eli funktio voi olla esim. => .deleteValue(1). Tämän takia me aikaisemmin käytettiin \"parseInt()\" funktiota, koska painikkeen alkuperäinen arvo eli => value=\"1\" ei ole sama asia kuin pelkästään 1.\n        .then(updatedList => { // Kun tiedot on poistettu tietokannasta, niin muutetaan \"persons\" muuttujan tilaa.\n          setPersons(persons.filter(newlist => newlist.id !== buttonID)) // Käytetään \"filter(...)\" funktiota, joka luo uuden taulukon (creates a new array). Jos \"persons.id\" on epätosi muuttujan \"buttonID\" kanssa, niin se filtteröidään nykyisestä taulukosta ja siirretään uuteen taulukkoon. Jos \"persons.id\" täsmää muuttujan \"buttonID\" kanssa, niin sitä ei huomioida ollenkaan.\n          setStatus(true) // Muutetaan \"status\" muuttujan arvoksi => \"true\". Tätä ei periaatteessa ei tarvitse olla tässä, koska jos henkilön poistaminen epäonnistuu, niin siinä muutetaan sama muuttuja arvoon => \"false\" ja sen jälkeen takaisin arvoon \"true\", mutta tällä varmistetaan aina se, että henkilön poistaminen renderöi oikean ilmoituksen takaisin käyttäjälle näkyviin.\n          setStatusMessage(` You have deleted ${getPerson.name} successfully from the phonebook! `) // Muutetaan \"statusMessage\" muuttujan arvo kyseiseen tekstiin. Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          setTimeout(() => { // Käytetään \"setTimeOut()\" funktiota, jotta saadaan ilmoitus poistumaan tietyn ajan päästä eli tässä tapauksessa ilmoitus poistuu näytöltä 2. sekunnin (eli 2000 ms) kuluttua.\n            setStatusMessage(null) // Muutetaan \"statusMessage\" muuttujan arvoksi => \"null\". Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          }, 2000)\n      })\n      .catch(error => { // Mikäli tulee virheitä, kun yritetään poistaa henkilöä puhelinluettelosta, niin ohjelma suorittaa {...} sisällä olevat asiat ja renderöi ne takaisin käyttäjälle näkyviin.\n        setStatus(false) // Muutetaan \"status\" muuttujan arvoksi => \"false\". Muista, että kyseinen muuttuja on yhtä kuin {checkStatus} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n        setStatusMessage(` Deleting ${getPerson.name} from the phonebook was unsuccessful. Please try again! :) `) // Muutetaan \"statusMessage\" muuttujan arvo kyseiseen tekstiin. Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n        setTimeout(() => { // Käytetään \"setTimeOut()\" funktiota, jotta saadaan ilmoitus poistumaan tietyn ajan päästä eli tässä tapauksessa ilmoitus poistuu näytöltä 3. sekunnin (eli 3000 ms) kuluttua.\n          setStatus(true) // Muutetaan \"status\" muuttuja oletusarvoon eli \"true\". Muista, että kyseinen muuttuja on yhtä kuin {checkStatus} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n          setStatusMessage(null) // Muutetaan \"statusMessage\" muuttujan arvoksi => \"null\". Muista, että kyseinen muuttuja on yhtä kuin {message} <=> \"Notification\" komponentin sisällä oleva muuttuja.\n        }, 3000)\n      })\n    }\n  }\n\n  return (\n    <div>\n      <h2>Phonebook</h2>\n        <Notification message={statusMessage} checkStatus={status} />\n        <InputComponent valueProps={filterName} onChangeProps={handleFilterNameChange} placeholderProps={inputTextFilter} />\n      <h2>Add new information to the phonebook!</h2>\n        <FormComponent onSubmitProps={submitPerson} nameValue={newName} nameChange={handleNameChange} namePlace={inputTextName} numberValue={newNumber} numberChange={handleNumberChange} numberPlace={inputTextNumber} typeProps=\"submit\" />\n      <h2>Numbers</h2>\n        <PersonsComponent personValue={persons} filterNameValue={filterName} deleteValue={handlePersonDelete} />\n    </div>\n  )\n}\n\nexport default App\n","// This exercise has been commented by Aarni Pavlidi, if you have any questions or suggestions with the code,\r\n// then please contact me by sending email at me@aarnipavlidi.fi <3\r\n\r\nimport React from 'react' // Otetaan \"React\" kirjaston sisältö käyttöön.\r\nimport ReactDOM from 'react-dom' // Otetaan \"ReactDOM\" kirjaston sisältö käyttöön.\r\nimport App from './App' // Tuodaan (import) App.js käytettäväksi.\r\nimport './index.css' // Tuodaan (import) tyylitiedosto => index.css käytettäväksi.\r\n\r\nReactDOM.render(<App />, document.getElementById('root')) \r\n"],"sourceRoot":""}